// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group TypeObjectSource;

main(ctx, definitions) ::= <<
$fileHeader(file=[ctx.filename, "TypeObject.cpp"], description=["This source file contains the definition of the described types in the IDL file."])$

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "$ctx.filename$TypeObject.h"
#include <utility>
$if(ctx.cdr)$
#include <fastcdr/Cdr.h>

$endif$
$if(ctx.fastcdr)$
#include <fastcdr/FastCdr.h>

$endif$

$ctx.filename$TypeFactory::$ctx.filename$TypeFactory()
{
    // Generate basic TypeIdentifiers
    TypeIdentifier *auxIdent;
    // TK_BOOLEAN:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_BOOLEAN);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("bool", auxIdent));
    // TK_BYTE_TYPE:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_BYTE_TYPE);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("uint8_t", auxIdent));
    // TK_INT16_TYPE:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_INT16_TYPE);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("int16_t", auxIdent));
    // TK_INT32_TYPE:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_INT32_TYPE);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("int32_t", auxIdent));
    // TK_INT64_TYPE:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_INT64_TYPE);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("int64_t", auxIdent));
    // TK_UINT16_TYPE:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_UINT16_TYPE);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("uint16_t", auxIdent));
    // TK_UINT32_TYPE:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_UINT32_TYPE);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("uint32_t", auxIdent));
    // TK_UINT64_TYPE:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_UINT64_TYPE);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("uint64_t", auxIdent));
    // TK_FLOAT32_TYPE:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_FLOAT32_TYPE);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("float", auxIdent));
    // TK_FLOAT64_TYPE:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_FLOAT64_TYPE);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("double", auxIdent));
    // TK_FLOAT128_TYPE:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_FLOAT128_TYPE);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("long double", auxIdent));
    // TK_CHAR8_TYPE:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_CHAR8_TYPE);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("char", auxIdent));
    // TK_CHAR16_TYPE:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TK_CHAR16_TYPE);
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("wchar", auxIdent));

    // Not basic, but "standard"
    // TI_STRING8_SMALL:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TI_STRING8_SMALL);
    auxIdent->string_sdefn.bound() = 255;
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("string_255", auxIdent));
    // TI_STRING16_SMALL:
    auxIdent = new TypeIdentifier;
    auxIdent->_d(TI_STRING16_SMALL);
    auxIdent->string_sdefn.bound() = 255;
    m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("wstring_255", auxIdent));
    // TI_STRING8_LARGE:
    //auxIdent = new TypeIdentifier;
    //auxIdent->_d(TI_STRING8_LARGE);
    //m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("string", auxIdent));
    // TI_STRING16_LARGE:
    //auxIdent = new TypeIdentifier;
    //auxIdent->_d(TI_STRING16_LARGE);
    //m_Identifiers.insert(std::pair<std::string, TypeIdentifier>("std::wstring", auxIdent));
}

$ctx.filename$TypeFactory::~$ctx.filename$TypeFactory()
{
    m_Identifiers.iterator id_it = m_Identifiers.begin();
    while (id_it != m_Identifiers.end())
    {
        delete *(id_it->second);
    }
    m_Identifiers.clear();

    m_Objects.iterator obj_it = m_Objects.begin();
    while (obj_it != m_Objects.end())
    {
        delete *(obj_it->second);
    }
    m_Objects.clear();
}

TypeIdentifier* $ctx.filename$TypeFactory::getBasicIdentifier(std::string &basic_type_name)
{
    if (m_Identifiers.find(basic_type_name) != m_Identifiers.end())
    {
        return m_Identifiers[basic_type_name];
    }
    return nullptr;
}

TypeIdentifier* $ctx.filename$TypeFactory::getStringIdentifier(uint32_t bound, bool wide)
{
    std::stringstream type;
    type << ((wide) ? "string_" : "wstring_") << bound;

    TypeIdentifier* auxIdent;

    if (m_Identifiers.find(type.str()) != m_Identifiers.end())
    {
        return m_Identifiers[type.str()];
    }
    else
    {
        if (bound < 256)
        {
            auxIdent->_d(wide ? TI_STRING16_SMALL : TI_STRING8_SMALL);
            auxIdent->string_sdefn.bound() = static_cast<octet>(bound);
        }
        else
        {
            auxIdent->_d(wide ? TI_STRING16_LARGE : TI_STRING8_LARGE);
            auxIdent->string_ldefn.bound() = bound;
        }
        m_Identifiers[type.str()] = auxIdent;
    }
    return auxIdent;
}

TypeIdentifier* $ctx.filename$TypeFactory::getSequenceIdentifier(TypeIdentifier *type, uint32_t bound)
{
    std::stringstream auxType;
    auxType << "sequence_" << type << "_" << bound;

    TypeIdentifier* auxIdent;

    if (m_Identifiers.find(auxType.str()) != m_Identifiers.end())
    {
        return m_Identifiers[auxType.str()];
    }
    else
    {
        if (bound < 256)
        {
            auxIdent->_d(TI_PLAIN_SEQUENCE_SMALL);
            auxIdent->seq_sdefn().bound() = static_cast<octet>(bound);
            auxIdent->seq_sdefn().element_identifier() = type;
            auxIdent->seq_sdefn().header().element_flags().TRY_CONSTRUCT1(false);
            auxIdent->seq_sdefn().header().element_flags().TRY_CONSTRUCT2(false);
            auxIdent->seq_sdefn().header().element_flags().IS_EXTERNAL(false);
            auxIdent->seq_sdefn().header().element_flags().IS_OPTIONAL(false);
            auxIdent->seq_sdefn().header().element_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->seq_sdefn().header().element_flags().IS_KEY(false);
            auxIdent->seq_sdefn().header().element_flags().IS_DEFAULT(false);

            SerializedPayload_t payload(
                MemberFlags::getMaxCdrSerializedSize() +
                TypeIdentifier::getMaxCdrSerializedSize() + 1 + 4);
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size);
            // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
            eprosima::fastcdr::Cdr ser(
                fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = CDR_LE;

            ser << static_cast<octet>(bound);
            auxIdent->seq_sdefn().element_identifier()->serialize(ser);
            auxIdent->seq_sdefn().header().element_flags().serialize(ser);
            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            MD5 objectHash();
            objectHash.update(payload->data);
            objectHash.finalize();
            for(int i = 0; i < 14; ++i)
            {
                auxIdent->seq_sdefn().header().equiv_kind()[i] = objectHash.digest[i];
            }
        }
        else
        {
            auxIdent->_d(TI_PLAIN_SEQUENCE_LARGE);
            auxIdent->seq_ldefn().bound() = bound;
            auxIdent->seq_ldefn().element_identifier() = type;
            auxIdent->seq_ldefn().header().element_flags().TRY_CONSTRUCT1(false);
            auxIdent->seq_ldefn().header().element_flags().TRY_CONSTRUCT2(false);
            auxIdent->seq_ldefn().header().element_flags().IS_EXTERNAL(false);
            auxIdent->seq_ldefn().header().element_flags().IS_OPTIONAL(false);
            auxIdent->seq_ldefn().header().element_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->seq_ldefn().header().element_flags().IS_KEY(false);
            auxIdent->seq_ldefn().header().element_flags().IS_DEFAULT(false);

            SerializedPayload_t payload(
                MemberFlags::getMaxCdrSerializedSize() +
                TypeIdentifier::getMaxCdrSerializedSize() + 4 + 4);
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size);
            // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
            eprosima::fastcdr::Cdr ser(
                fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = CDR_LE;

            ser << static_cast<octet>(bound);
            auxIdent->seq_ldefn().element_identifier()->serialize(ser);
            auxIdent->seq_ldefn().header().element_flags().serialize(ser);
            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            MD5 objectHash();
            objectHash.update(payload->data);
            objectHash.finalize();
            for(int i = 0; i < 14; ++i)
            {
                auxIdent->seq_ldefn().header().equiv_kind()[i] = objectHash.digest[i];
            }
        }
        m_Identifiers[auxType.str()] = auxIdent;
    }

    return auxIdent;
}

TypeIdentifier* $ctx.filename$TypeFactory::getArrayIdentifier(TypeIdentifier *type, std::vector<uint32_t> &bound)
{
    std::stringstream auxType;
    auxType << "array_" << type;
    for (uint32_t b : bound)
    {
        auxType << "_" << b;
    }

    TypeIdentifier* auxIdent;

    if (m_Identifiers.find(auxType.str()) != m_Identifiers.end())
    {
        return m_Identifiers[auxType.str()];
    }
    else
    {
        if (bound.size() < 256)
        {
            auxIdent->_d(TI_PLAIN_ARRAY_SMALL);
            for (uint32_t b : bound)
            {
                auxIdent->array_sdefn().array_bound_seq().push_back(static_cast<octet>(b));
            }
            auxIdent->array_sdefn().element_identifier() = type;
            auxIdent->array_sdefn().header().element_flags().TRY_CONSTRUCT1(false);
            auxIdent->array_sdefn().header().element_flags().TRY_CONSTRUCT2(false);
            auxIdent->array_sdefn().header().element_flags().IS_EXTERNAL(false);
            auxIdent->array_sdefn().header().element_flags().IS_OPTIONAL(false);
            auxIdent->array_sdefn().header().element_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->array_sdefn().header().element_flags().IS_KEY(false);
            auxIdent->array_sdefn().header().element_flags().IS_DEFAULT(false);

            SerializedPayload_t payload(
                MemberFlags::getMaxCdrSerializedSize() +
                TypeIdentifier::getMaxCdrSerializedSize() + bound.size() + 4);
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size);
            // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
            eprosima::fastcdr::Cdr ser(
                fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = CDR_LE;

            ser << auxIdent->array_sdefn().array_bound_seq();
            auxIdent->array_sdefn().element_identifier()->serialize(ser);
            auxIdent->array_sdefn().header().element_flags().serialize(ser);
            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            MD5 objectHash();
            objectHash.update(payload->data);
            objectHash.finalize();
            for(int i = 0; i < 14; ++i)
            {
                auxIdent->array_sdefn().header().equiv_kind()[i] = objectHash.digest[i];
            }
        }
        else
        {
            auxIdent->_d(TI_PLAIN_ARRAY_LARGE);
            for (uint32_t b : bound)
            {
                auxIdent->array_ldefn().array_bound_seq().push_back(b);
            }
            auxIdent->array_ldefn().element_identifier() = type;
            auxIdent->array_ldefn().header().element_flags().TRY_CONSTRUCT1(false);
            auxIdent->array_ldefn().header().element_flags().TRY_CONSTRUCT2(false);
            auxIdent->array_ldefn().header().element_flags().IS_EXTERNAL(false);
            auxIdent->array_ldefn().header().element_flags().IS_OPTIONAL(false);
            auxIdent->array_ldefn().header().element_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->array_ldefn().header().element_flags().IS_KEY(false);
            auxIdent->array_ldefn().header().element_flags().IS_DEFAULT(false);

            SerializedPayload_t payload(
                MemberFlags::getMaxCdrSerializedSize() +
                TypeIdentifier::getMaxCdrSerializedSize() + (bound.size() * 4) + 4);
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size);
            // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
            eprosima::fastcdr::Cdr ser(
                fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = CDR_LE;

            ser << auxIdent->array_ldefn().array_bound_seq();
            auxIdent->array_ldefn().element_identifier()->serialize(ser);
            auxIdent->array_ldefn().header().element_flags().serialize(ser);
            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            MD5 objectHash();
            objectHash.update(payload->data);
            objectHash.finalize();
            for(int i = 0; i < 14; ++i)
            {
                auxIdent->array_ldefn().header().equiv_kind()[i] = objectHash.digest[i];
            }
        }
        m_Identifiers[auxType.str()] = auxIdent;
    }

    return auxIdent;
}

static size_t split(const std::string &txt, std::vector<uint32_t> &strs, char ch)
{
    size_t pos = txt.find( ch );
    size_t initialPos = 0;
    strs.clear();

    // Decompose statement
    while( pos != std::string::npos ) {
        strs.push_back( std::stoi( txt.substr( initialPos, pos - initialPos ) ) );
        initialPos = pos + 1;

        pos = txt.find( ch, initialPos );
    }

    // Add the last one
    strs.push_back( std::stoi( txt.substr( initialPos, std::min( pos, txt.size() ) - initialPos + 1 ) ) );

    return strs.size();
}

TypeIdentifier* $ctx.filename$TypeFactory::getArrayIdentifier(TypeIdentifier *type, std::string &bound)
{
    std::vector<uint32_t> vecBound;
    split(bound, vecBound, ' ');
    return getArrayIdentifier(type, vecBound);
}

TypeIdentifier* $ctx.filename$TypeFactory::getMapIdentifier(TypeIdentifier *keyType,
    TypeIdentifier *valueType, uint32_t bound)
{
    std::stringstream auxType;
    auxType << "map_" << keyType << "_" << valueType << "_" << bound;

    TypeIdentifier* auxIdent;

    if (m_Identifiers.find(auxType.str()) != m_Identifiers.end())
    {
        return m_Identifiers[auxType.str()];
    }
    else
    {
        if (bound < 256)
        {
            auxIdent->_d(TI_PLAIN_MAP_SMALL);
            auxIdent->map_sdefn().bound() = static_cast<octet>(bound);
            auxIdent->map_sdefn().element_identifier() = valueType;
            auxIdent->map_sdefn().key_identifier() = keyType;
            auxIdent->map_sdefn().header().element_flags().TRY_CONSTRUCT1(false);
            auxIdent->map_sdefn().header().element_flags().TRY_CONSTRUCT2(false);
            auxIdent->map_sdefn().header().element_flags().IS_EXTERNAL(false);
            auxIdent->map_sdefn().header().element_flags().IS_OPTIONAL(false);
            auxIdent->map_sdefn().header().element_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->map_sdefn().header().element_flags().IS_KEY(false);
            auxIdent->map_sdefn().header().element_flags().IS_DEFAULT(false);
            auxIdent->map_sdefn().key_flags().TRY_CONSTRUCT1(false);
            auxIdent->map_sdefn().key_flags().TRY_CONSTRUCT2(false);
            auxIdent->map_sdefn().key_flags().IS_EXTERNAL(false);
            auxIdent->map_sdefn().key_flags().IS_OPTIONAL(false);
            auxIdent->map_sdefn().key_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->map_sdefn().key_flags().IS_KEY(false);
            auxIdent->map_sdefn().key_flags().IS_DEFAULT(false);

            SerializedPayload_t payload(
                2 * MemberFlags::getMaxCdrSerializedSize() +
                2 * TypeIdentifier::getMaxCdrSerializedSize() + 1 + 4);
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size);
            // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
            eprosima::fastcdr::Cdr ser(
                fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = CDR_LE;

            ser << static_cast<octet>(bound);
            auxIdent->map_sdefn().element_identifier()->serialize(ser);
            auxIdent->map_sdefn().key_identifier()->serialize(ser);
            auxIdent->map_sdefn().header().element_flags().serialize(ser);
            auxIdent->map_sdefn().key_flags().serialize(ser);
            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            MD5 objectHash();
            objectHash.update(payload->data);
            objectHash.finalize();
            for(int i = 0; i < 14; ++i)
            {
                auxIdent->map_sdefn().header().equiv_kind()[i] = objectHash.digest[i];
            }
        }
        else
        {
            auxIdent->_d(TI_PLAIN_MAP_LARGE);
            auxIdent->map_ldefn().bound() = bound;
            auxIdent->map_ldefn().element_identifier() = valueType;
            auxIdent->map_ldefn().key_identifier() = keyType;
            auxIdent->map_ldefn().header().element_flags().TRY_CONSTRUCT1(false);
            auxIdent->map_ldefn().header().element_flags().TRY_CONSTRUCT2(false);
            auxIdent->map_ldefn().header().element_flags().IS_EXTERNAL(false);
            auxIdent->map_ldefn().header().element_flags().IS_OPTIONAL(false);
            auxIdent->map_ldefn().header().element_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->map_ldefn().header().element_flags().IS_KEY(false);
            auxIdent->map_ldefn().header().element_flags().IS_DEFAULT(false);
            auxIdent->map_ldefn().key_flags().TRY_CONSTRUCT1(false);
            auxIdent->map_ldefn().key_flags().TRY_CONSTRUCT2(false);
            auxIdent->map_ldefn().key_flags().IS_EXTERNAL(false);
            auxIdent->map_ldefn().key_flags().IS_OPTIONAL(false);
            auxIdent->map_ldefn().key_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->map_ldefn().key_flags().IS_KEY(false);
            auxIdent->map_ldefn().key_flags().IS_DEFAULT(false);

            SerializedPayload_t payload(
                2 * MemberFlags::getMaxCdrSerializedSize() +
                2 * TypeIdentifier::getMaxCdrSerializedSize() + 4 + 4);
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size);
            // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
            eprosima::fastcdr::Cdr ser(
                fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = CDR_LE;

            ser << static_cast<octet>(bound);
            auxIdent->map_ldefn().element_identifier()->serialize(ser);
            auxIdent->map_ldefn().key_identifier()->serialize(ser);
            auxIdent->map_ldefn().header().element_flags().serialize(ser);
            auxIdent->map_ldefn().key_flags().serialize(ser);
            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            MD5 objectHash();
            objectHash.update(payload->data);
            objectHash.finalize();
            for(int i = 0; i < 14; ++i)
            {
                auxIdent->map_ldefn().header().equiv_kind()[i] = objectHash.digest[i];
            }
        }
        m_Identifiers[auxType.str()] = auxIdent;
    }

    return auxIdent;
}

$definitions; separator="\n"$
>>

module(ctx, parent, module, definition_list) ::= <<
$definition_list$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

annotation(ctx, annotation) ::= <<>>

interface(ctx, parent, interface, export_list) ::= <<>>

export_list(exports) ::= <<>>

const_decl(ctx, parent, const) ::= <<>>

typedef_decl(ctx, parent, typedefs) ::= <<
TypeIdentifier* $typedefs.scopedname$::get$typedefs.name$Identifier()
{
    if (m_Identifiers.find("$typedefs.typedefContentTypeCode.cppTypename$") != m_Identifiers.end())
    {
        return m_Identifiers["$typedefs.typedefContentTypeCode.cppTypename$"];
    }
    return nullptr;
}

TypeObject* $typedefs.scopedname$::get$typedefs.name$Object()
{
    if (m_Objects.find("$typedefs.name$") != m_Objects.end())
    {
        return m_Objects["$typedefs.name$"];
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already
    type_object->minimal().alias_type().body().common().related_type() =
        *m_Identifiers["$typedefs.typedefContentTypeCode.cppTypename$"]; // Make a copy

    // Don't add our TypeIdentifier

    m_Objects["$typedefs.name$"] = type_object;
}

>>

enum_type(ctx, parent, enum) ::= <<
TypeIdentifier* $enum.scopedname$::get$enum.name$Identifier()
{
    if (m_Identifiers.find("$enum.name$") != m_Identifiers.end())
    {
        return m_Identifiers["$enum.name$"];
    }

    TypeObject* type_object;
    if (m_Objects.find("$enum.name$") != m_Objects.end())
    {
        type_object = m_Objects["$enum.name$"];
    }
    else
    {
        type_object = get$enum.name$Object();
    }

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(MinimalEnumeratedType::getMaxCdrSerializedSize() + 4);
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIAN,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = CDR_LE;


    type_object->serialize(ser);
    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash();
    objectHash.update(payload->data);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash[i] = objectHash.digest[i];
    }

    m_Identifiers["$enum.name$"] = identifier;
}

TypeObject* $enum.scopedname$::get$enum.name$Object()
{
    if (m_Objects.find("$enum.name$") != m_Objects.end())
    {
        return m_Objects["$enum.name$"];
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);
    // Unused
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound() = 32; // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    $enum.members:{ member | $enumerated_literal(ctx=ctx, object=member)$}; separator="\n"$

    m_Objects["$enum.name$"] = type_object;
}

>>

enumerated_literal(ctx, object) ::= <<
MinimalEnumeratedLiteral mel_$object.name$;
mel_$object.name$.common().member_id() = MEMBER_ID_INVALID; // Es esto correcto?
mel_$object.name$.common().flags().TRY_CONSTRUCT1(false);
mel_$object.name$.common().flags().TRY_CONSTRUCT2(false);
mel_$object.name$.common().flags().IS_EXTERNAL(false);
mel_$object.name$.common().flags().IS_OPTIONAL(false);
mel_$object.name$.common().flags().IS_MUST_UNDERSTAND(false);
mel_$object.name$.common().flags().IS_KEY(false);
mel_$object.name$.common().flags().IS_DEFAULT(false);
mel_$object.name$.common().flags().IS_DEFAULT(false);
mel_$object.name$.common().value() = value++;
MD5 $object.name$_hash("$object.name$");
for(int i = 0; i < 4; ++i)
{
    mel_$object.name$.detail().name_hash()[i] = $object.name$_hash.digest[i];
}
type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_$object.name$);

>>

struct_type(ctx, parent, struct, extensions) ::= <<
TypeIdentifier* $struct.scopedname$::get$struct.name$Identifier()
{
    TypeObject* type_object;
    if (m_Objects.find("$enum.name$") != m_Objects.end())
    {
        type_object = m_Objects["$enum.name$"];
    }
    else
    {
        type_object = get$enum.name$Object();
    }

    return &(type_object->minimal().struct_type().header().base_type());
}

TypeObject* $struct.scopedname$::get$struct.name$Object()
{
    if (m_Objects.find("$struct.name$") != m_Objects.end())
    {
        return m_Objects["$struct.name$"];
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    $struct.members:{ member | $member_object_type(ctx=ctx, object=member)$}; separator="\n"$

    // Header
    type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    // TODO De momento lo haremos sólo con miembros... ¿también con flags?
    // Como no soportamos de momento tipos recursivos, esto debería bastar.
    SerializedPayload_t payload(
        type_object->minimal().struct_type().member_seq().size() * sizeof(MinimalStructMember) + 4);
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.

    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = CDR_LE;
    // Serialize encapsulation

    for (MinimalStructMember &st : type_object->minimal().struct_type().member_seq())
    {
        ser << st;
    }
    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash();
    objectHash.update(payload->data);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        type_object->minimal().struct_type().header().base_type().equivalence_hash()[i] = objectHash.digest[i];
    }

    m_Objects["$struct.name$"] = type_object;
}

>>

member_object_type(ctx, object) ::= <<
MinimalStructMember mst_$object.name$;
mst_$object.name$.common().member_id() = MEMBER_ID_INVALID;
mst_$object.name$.common().member_flags().TRY_CONSTRUCT1(false);
mst_$object.name$.common().member_flags().TRY_CONSTRUCT2(false);
mst_$object.name$.common().member_flags().IS_EXTERNAL(false);
mst_$object.name$.common().member_flags().IS_OPTIONAL(false);
mst_$object.name$.common().member_flags().IS_MUST_UNDERSTAND(false);
mst_$object.name$.common().member_flags().IS_KEY(false);
mst_$object.name$.common().member_flags().IS_DEFAULT(false);
$if(object.typecode.plainType)$
mst_$object.name$.common().member_type_id($get_type_identifier_recursive(ctx=ctx, type=object.typecode)$);
$else$
mst_$object.name$.common().member_type_id(m_Identifiers["$object.typecode.cppTypename$"]);
$endif$

MD5 $object.name$_hash("$object.name$");
for(int i = 0; i < 4; ++i)
{
    mst_$object.name$.detail().name_hash()[i] = $object.name$_hash.digest[i];
}
type_object->minimal().struct_type().member_seq().emplace_back(mst_$object.name$);

>>

get_type_identifier_recursive(ctx, type) ::= <<$if(type.isSequenceType)$getSequenceIdentifier($get_type_identifier_recursive(ctx=ctx, type=type.sequenceContentTypeCode)$, $type.maxsize$)$elseif(type.isArrayType)$getArrayIdentifier($get_type_identifier_recursive(ctx=ctx, type=type.arrayContentTypeCode)$, "$type.dimensions:{ dim |$dim$}; separator=" "$")$elseif(type.isSetType)$getSequenceIdentifier($get_type_identifier_recursive(ctx=ctx, type=type.setContentTypeCode)$, $type.maxsize$)$elseif(type.isMapType)$getMapIdentifier($get_type_identifier_recursive(ctx=ctx, type=type.keyTypeCode)$, $get_type_identifier_recursiv(ctx=ctx, type=type.valueTypeCode)$, $type.maxsize$)$elseif(type.isStringType)$getStringIdentifier($type.maxsize$, false)$elseif(type.isWStringType)$getStringIdentifier($type.maxsize$, true)$else$m_Identifiers["$type.cppTypename$"]$endif$>>

union_type(ctx, parent, union) ::= <<
TypeIdentifier* $union.scopedname$::get$union.name$Identifier()
{
    if (m_Identifiers.find("$union.name$") != m_Identifiers.end())
    {
        return m_Identifiers["$union.name$"];
    }

    TypeObject* type_object;
    if (m_Objects.find("$union.name$") != m_Objects.end())
    {
        type_object = m_Objects["$union.name$"];
    }
    else
    {
        type_object = get$union.name$Object();
    }

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(MinimalUnionType::getMaxCdrSerializedSize() + 4);
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIAN,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = CDR_LE;


    type_object->serialize(ser);
    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash();
    objectHash.update(payload->data);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash[i] = objectHash.digest[i];
    }

    m_Identifiers["$union.name$"] = identifier;
}

TypeObject* $union.scopedname$::get$union.name$Object()
{
    if (m_Objects.find("$union.name$") != m_Objects.end())
    {
        return m_Objects["$union.name$"];
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false);

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->minimal().union_type().discriminator().common().type_id($get_type_identifier_recursive(ctx=ctx, type=union.discriminator)$);

    $union.members:{ member | $union_member_object_type(ctx=ctx, object=member)$}; separator="\n"$

    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    m_Objects["$union.name$"] = type_object;
}

>>

union_member_object_type(ctx, object) ::= <<
MinimalUnionMember mst_$object.name$;
mst_$object.name$.common().member_id() = MEMBER_ID_INVALID;
mst_$object.name$.common().member_flags().TRY_CONSTRUCT1(false);
mst_$object.name$.common().member_flags().TRY_CONSTRUCT2(false);
mst_$object.name$.common().member_flags().IS_EXTERNAL(false);
mst_$object.name$.common().member_flags().IS_OPTIONAL(false);
mst_$object.name$.common().member_flags().IS_MUST_UNDERSTAND(false);
mst_$object.name$.common().member_flags().IS_KEY(false);
mst_$object.name$.common().member_flags().IS_DEFAULT(false);
$if(object.typecode.plainType)$
mst_$object.name$.common().type_id($get_type_identifier_recursive(ctx=ctx, type=object.typecode)$);
$else$
mst_$object.name$.common().type_id(m_Identifiers["$object.typecode.cppTypename$"]);
$endif$

$if(object.labels)$
$object.labels:{ label | mst_$object.name$.common().label_seq().emplace_back($label$);}; separator="\n"$
$endif$

MD5 $object.name$_hash("$object.name$");
for(int i = 0; i < 4; ++i)
{
    mst_$object.name$.detail().name_hash()[i] = $object.name$_hash.digest[i];
}
type_object->minimal().union_type().member_seq().emplace_back(mst_$object.name$);

>>

/***** Utils *****/

